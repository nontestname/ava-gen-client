# Action Plan Client-Side Design

This document captures the client-side data model for executing **Action Plans** generated by the Test2VA server.

The goal: instead of hard-coded, per-app Java methods, the Android client executes a **JSON-defined action plan** composed of primitive UI actions (click, input, scroll, etc.) targeting nodes via `NodeQuery`.

---

## 1. Example Server JSON (per app)

Example file: `hu.vmiklos.plees_tracker_actionplan.json`

```json
{
  "app_id": "hu.vmiklos.plees_tracker",
  "action_plans": {
    "accessStatistics": {
      "method_name": "accessStatistics",
      "steps": [
        {
          "action": "sleep",
          "matchers": [],
          "text": null,
          "millis": 1000,
          "node_query": null
        },
        {
          "action": "click",
          "matchers": [
            { "type": "contentDescription", "value": "More options" }
          ],
          "text": null,
          "millis": null,
          "node_query": "withContentDescription(\"More options\")"
        }
      ]
    }
  }
}
```

**Notes**

- `"app_id"` identifies the target Android app.
- `"action_plans"` is a map: `VA method name -> ActionPlan`.
- Each `ActionPlan` contains a list of primitive `steps`.
- Each `step` has an `action` (sleep, click, etc.), optional `matchers`, `text`, `millis`, and an optional `node_query` string.

---

## 2. Top-Level Container: `AppActionPlans`

Represents all action plans for a **single app**.

**Fields**

- `String appId`  
  maps from JSON `"app_id"`
- `Map<String, ActionPlan> actionPlans`  
  maps from JSON `"action_plans"`  
  - key: VA method name, e.g. `"accessStatistics"`  
  - value: corresponding `ActionPlan`

**Purpose**

- Loaded once when the client opens the per-app JSON file.
- Cached by `appId` so that subsequent requests for the same app do not re-parse JSON.
- Provides a lookup method like `getPlanForMethod(String methodName)`.

---

## 3. `ActionPlan`

Represents one VA method’s plan (e.g., `accessStatistics`).

**Fields**

- `String methodName`  
  - from JSON `"method_name"`
- `List<ActionStep> steps`  
  - from JSON `"steps"`

**Optional Extensions (Future)**

- `String description`  
- `String planId`  
- `long createdAt`  

These are not in the current JSON, but the model can easily grow to include them if the server starts emitting additional metadata.

**Behavior**

- `boolean isEmpty()` convenience helper.
- `String toString()` for logging.

---

## 4. `ActionStep`

Represents a single primitive UI operation in a plan.

**Fields**

- `String action` (raw)  
  - from JSON `"action"` (e.g., `"sleep"`, `"click"`, `"input_text"`)
  - mapped lazily to an enum `ActionType` for type safety.
- `List<StepMatcher> matchers`  
  - from JSON `"matchers"`
- `String text` (nullable)  
  - from JSON `"text"` (e.g., input text for `INPUT_TEXT`)
- `Long millis` (nullable)  
  - from JSON `"millis"` (e.g., sleep time)
- `String nodeQueryExpr` (nullable)  
  - from JSON `"node_query"`  
  - text form of a `NodeQuery`, e.g. `withContentDescription("More options")`

**Derived / Client-Only Fields**

- `NodeQuery nodeQuery` (transient)  
  - constructed client-side by parsing `nodeQueryExpr` or synthesizing from `matchers`.
- `ActionType actionType` (transient)  
  - enum wrapper around `action` with logic like `requiresNode()`.

**Example Responsibilities**

- `ActionType getActionType()` → maps raw string to enum.
- `boolean requiresTargetNode()` → delegate to `ActionType.requiresNode()`.

---

## 5. `StepMatcher`

Represents one element in the `"matchers"` array.

**Fields**

- `String type`  
  - from JSON `"type"` (e.g., `"contentDescription"`, `"text"`, `"id"`)
- `String value`  
  - from JSON `"value"`

**Intended Mapping to NodeQuery**

- `type = "contentDescription"` → `withContentDescription(value)`  
- `type = "text"` → `withText(value)`  
- `type = "id"` → `withId(value)`  

This allows two strategies for building `NodeQuery` on the client:

1. Parse `nodeQueryExpr` string into a `NodeQuery` AST, **or**
2. Ignore `nodeQueryExpr` and rebuild the `NodeQuery` from the list of `StepMatcher` objects.

The design supports either or both approaches.

---

## 6. `ActionType` Enum

Client-side enum for known `action` values. The raw strings must match what the server/action plan parser emits.

Example members:

- `SLEEP("sleep", false)`  
- `CLICK("click", true)`  
- `INPUT_TEXT("input_text", true)`  
- `SCROLL("scroll", true)`  
- `GLOBAL_BACK("global_back", false)`  
- `UNKNOWN("unknown", false)`  

Each enum value can carry:

- `String raw` → exact string used in JSON.
- `boolean requiresNode` → whether an `AccessibilityNodeInfo` target is mandatory.

Helper:

- `static ActionType fromRaw(String raw)` → maps incoming JSON to enum.

---

## 7. How the Client Uses These Classes

### 7.1 Loading Action Plans

1. Read per-app JSON (e.g., from assets, local storage, or server cache).
2. Deserialize to `AppActionPlans` (e.g., using Gson).
3. Cache `AppActionPlans` by `appId`.

```java
String json = loadFromAssets("hu.vmiklos.plees_tracker_actionplan.json");
AppActionPlans appPlans = AppActionPlans.fromJson(json);

ActionPlan plan = appPlans.getPlanForMethod("accessStatistics");
```

### 7.2 Executing a VA Method via ActionPlan

When the server asks the client to execute a VA method (e.g., `"accessStatistics"`):

1. Look up the corresponding plan:

   ```java
   ActionPlan plan = appPlans.getPlanForMethod("accessStatistics");
   ```

2. Hand it to the executor:

   ```java
   actionPlanExecutor.executePlan(appId, plan);
   ```

3. Inside `ActionPlanExecutor`:

   - Loop over `plan.getSteps()`.
   - For each `ActionStep`:
     - Map `action` string to `ActionType`.
     - Build/parse `NodeQuery` from `nodeQueryExpr` and/or `matchers`.
     - Dispatch to `ActionPerformer`:
       - `performClick(node)`  
       - `performInput(node, text)`  
       - `performScroll(node, dir)`  
       - `sleep(millis)`  
       - `performBack()`  
       - etc.

### 7.3 Relationship to Existing Client Pieces

- `ActionPlanExecutor` replaces the old reflection-based `AppTaskExecutor`.
- `NodeQueryExecutor` + `ActionPerformer` reuse your existing Accessibility logic.
- `TaskRegistry` no longer needs to know app-specific methods; at most, it can store per-app configuration (package name, entry activity, etc.).

---

## 8. Summary

- **Server**: produces per-app JSON files describing VA methods as **ActionPlans**.
- **Client**: uses `AppActionPlans`, `ActionPlan`, `ActionStep`, `StepMatcher`, and `ActionType` to:
  - Parse the JSON.
  - Map abstract steps to concrete `NodeQuery` operations.
  - Execute them through Accessibility APIs.

This design removes hard-coded, per-app VA methods on the client and replaces them with a generic, extensible execution engine driven entirely by server-generated Action Plans.
